//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../axios-client';
import { getAxios, getBaseUrl } from './helpers';

/**
 * @param body (optional) 
 * @return Success
 */
export function apiKeyPOST(body?: Types.CreateApiKeyCommand | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.CreateApiKeyCommandDto> {
    let url_ = getBaseUrl() + "/api/ApiKey";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigApiKeyPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApiKeyPOST(_response);
    });
}

function processApiKeyPOST(response: AxiosResponse): Promise<Types.CreateApiKeyCommandDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        return throwException("Created", status, _responseText, _headers);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.CreateApiKeyCommandDto.fromJS(resultData200);
        return Promise.resolve<Types.CreateApiKeyCommandDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CreateApiKeyCommandDto>(null as any);
}

/**
 * @return Success
 */
export function apiKeyAll(config?: AxiosRequestConfig | undefined): Promise<Types.CreateApiKeyCommandDto[]> {
    let url_ = getBaseUrl() + "/api/ApiKey";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigApiKeyAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApiKeyAll(_response);
    });
}

function processApiKeyAll(response: AxiosResponse): Promise<Types.CreateApiKeyCommandDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.CreateApiKeyCommandDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.CreateApiKeyCommandDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CreateApiKeyCommandDto[]>(null as any);
}

/**
 * @return Success
 */
export function apiKeyDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/ApiKey/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigApiKeyDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApiKeyDELETE(_response);
    });
}

function processApiKeyDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function login(body?: Types.LoginCommand | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.AuthenticationResponse> {
    let url_ = getBaseUrl() + "/api/Auth/Login";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLogin,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLogin(_response);
    });
}

function processLogin(response: AxiosResponse): Promise<Types.AuthenticationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 202) {
        const _responseText = response.data;
        return throwException("Accepted", status, _responseText, _headers);

    } else if (status === 401) {
        const _responseText = response.data;
        let result401: any = null;
        let resultData401  = _responseText;
        result401 = Types.ProblemDetails.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);

    } else if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.ProblemDetails.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AuthenticationResponse.fromJS(resultData200);
        return Promise.resolve<Types.AuthenticationResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AuthenticationResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function register(body?: Types.RegisterCommand | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.AuthenticationResponse> {
    let url_ = getBaseUrl() + "/api/Auth/Register";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRegister,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRegister(_response);
    });
}

function processRegister(response: AxiosResponse): Promise<Types.AuthenticationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.ProblemDetails.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AuthenticationResponse.fromJS(resultData200);
        return Promise.resolve<Types.AuthenticationResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AuthenticationResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function conversion(body?: Types.CreateConversionCommand[] | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/Conversion";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigConversion,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConversion(_response);
    });
}

function processConversion(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        return throwException("Created", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @param conversionDate_From (optional) 
 * @param conversionDate_To (optional) 
 * @param fileName (optional) 
 * @param formats (optional) 
 * @param isDeleted (optional) 
 * @return Success
 */
export function conversionAll(conversionDate_From?: Date | undefined, conversionDate_To?: Date | undefined, fileName?: string | undefined, formats?: Types.TargetFileFormat[] | undefined, isDeleted?: boolean | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.GetConversionQueryDto[]> {
    let url_ = getBaseUrl() + "/api/Conversion?";
    if (conversionDate_From === null)
        throw new Error("The parameter 'conversionDate_From' cannot be null.");
    else if (conversionDate_From !== undefined)
        url_ += "ConversionDate.From=" + encodeURIComponent(conversionDate_From ? "" + conversionDate_From.toISOString() : "") + "&";
    if (conversionDate_To === null)
        throw new Error("The parameter 'conversionDate_To' cannot be null.");
    else if (conversionDate_To !== undefined)
        url_ += "ConversionDate.To=" + encodeURIComponent(conversionDate_To ? "" + conversionDate_To.toISOString() : "") + "&";
    if (fileName === null)
        throw new Error("The parameter 'fileName' cannot be null.");
    else if (fileName !== undefined)
        url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
    if (formats === null)
        throw new Error("The parameter 'formats' cannot be null.");
    else if (formats !== undefined)
        formats && formats.forEach(item => { url_ += "Formats=" + encodeURIComponent("" + item) + "&"; });
    if (isDeleted === null)
        throw new Error("The parameter 'isDeleted' cannot be null.");
    else if (isDeleted !== undefined)
        url_ += "IsDeleted=" + encodeURIComponent("" + isDeleted) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigConversionAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConversionAll(_response);
    });
}

function processConversionAll(response: AxiosResponse): Promise<Types.GetConversionQueryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.GetConversionQueryDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.GetConversionQueryDto[]>(result200);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.GetConversionQueryDto[]>(null as any);
}

/**
 * @return Success
 */
export function download(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.FileResponse> {
    let url_ = getBaseUrl() + "/api/Conversion/Download/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDownload,
        ...config,
        responseType: "blob",
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDownload(_response);
    });
}

function processDownload(response: AxiosResponse): Promise<Types.FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200 || status === 206) {
        const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
        let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
        let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
        if (fileName) {
            fileName = decodeURIComponent(fileName);
        } else {
            fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
        }
        return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FileResponse>(null as any);
}

/**
 * @return Success
 */
export function convertionResults(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.GetConversionQueryDto[]> {
    let url_ = getBaseUrl() + "/api/Conversion/ConvertionResults/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigConvertionResults,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConvertionResults(_response);
    });
}

function processConvertionResults(response: AxiosResponse): Promise<Types.GetConversionQueryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.GetConversionQueryDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.GetConversionQueryDto[]>(result200);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.GetConversionQueryDto[]>(null as any);
}

/**
 * @return No Content
 */
export function softDelete(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Conversion/SoftDelete/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSoftDelete,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSoftDelete(_response);
    });
}

function processSoftDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 204) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return No Content
 */
export function hardDelete(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Conversion/HardDelete/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigHardDelete,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processHardDelete(_response);
    });
}

function processHardDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 204) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return No Content
 */
export function cancelDelete(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Conversion/CancelDelete/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCancelDelete,
        ...config,
        method: "PATCH",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCancelDelete(_response);
    });
}

function processCancelDelete(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 204) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function profileGET(config?: AxiosRequestConfig | undefined): Promise<Types.ProfileInfoDto> {
    let url_ = getBaseUrl() + "/api/Profile";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigProfileGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processProfileGET(_response);
    });
}

function processProfileGET(response: AxiosResponse): Promise<Types.ProfileInfoDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ProfileInfoDto.fromJS(resultData200);
        return Promise.resolve<Types.ProfileInfoDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ProfileInfoDto>(null as any);
}

/**
 * @param body (optional) 
 * @return No Content
 */
export function profilePATCH(body?: Types.UpdateProfileInfoCommand | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Profile";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigProfilePATCH,
        ...config,
        data: content_,
        method: "PATCH",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processProfilePATCH(_response);
    });
}

function processProfilePATCH(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 204) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status === 404) {
        const _responseText = response.data;
        let result404: any = null;
        let resultData404  = _responseText;
        result404 = Types.ProblemDetails.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function getWeatherForecast(config?: AxiosRequestConfig | undefined): Promise<Types.WeatherForecast[]> {
    let url_ = getBaseUrl() + "/WeatherForecast";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetWeatherForecast,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetWeatherForecast(_response);
    });
}

function processGetWeatherForecast(response: AxiosResponse): Promise<Types.WeatherForecast[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.WeatherForecast.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.WeatherForecast[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WeatherForecast[]>(null as any);
}
let _requestConfigApiKeyPOST: Partial<AxiosRequestConfig> | null;
export function getApiKeyPOSTRequestConfig() {
  return _requestConfigApiKeyPOST;
}
export function setApiKeyPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApiKeyPOST = value;
}
export function patchApiKeyPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApiKeyPOST = patch(_requestConfigApiKeyPOST ?? {});
}

let _requestConfigApiKeyAll: Partial<AxiosRequestConfig> | null;
export function getApiKeyAllRequestConfig() {
  return _requestConfigApiKeyAll;
}
export function setApiKeyAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApiKeyAll = value;
}
export function patchApiKeyAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApiKeyAll = patch(_requestConfigApiKeyAll ?? {});
}

let _requestConfigApiKeyDELETE: Partial<AxiosRequestConfig> | null;
export function getApiKeyDELETERequestConfig() {
  return _requestConfigApiKeyDELETE;
}
export function setApiKeyDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApiKeyDELETE = value;
}
export function patchApiKeyDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApiKeyDELETE = patch(_requestConfigApiKeyDELETE ?? {});
}

let _requestConfigLogin: Partial<AxiosRequestConfig> | null;
export function getLoginRequestConfig() {
  return _requestConfigLogin;
}
export function setLoginRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLogin = value;
}
export function patchLoginRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLogin = patch(_requestConfigLogin ?? {});
}

let _requestConfigRegister: Partial<AxiosRequestConfig> | null;
export function getRegisterRequestConfig() {
  return _requestConfigRegister;
}
export function setRegisterRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRegister = value;
}
export function patchRegisterRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRegister = patch(_requestConfigRegister ?? {});
}

let _requestConfigConversion: Partial<AxiosRequestConfig> | null;
export function getConversionRequestConfig() {
  return _requestConfigConversion;
}
export function setConversionRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConversion = value;
}
export function patchConversionRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConversion = patch(_requestConfigConversion ?? {});
}

let _requestConfigConversionAll: Partial<AxiosRequestConfig> | null;
export function getConversionAllRequestConfig() {
  return _requestConfigConversionAll;
}
export function setConversionAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConversionAll = value;
}
export function patchConversionAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConversionAll = patch(_requestConfigConversionAll ?? {});
}

let _requestConfigDownload: Partial<AxiosRequestConfig> | null;
export function getDownloadRequestConfig() {
  return _requestConfigDownload;
}
export function setDownloadRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDownload = value;
}
export function patchDownloadRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDownload = patch(_requestConfigDownload ?? {});
}

let _requestConfigConvertionResults: Partial<AxiosRequestConfig> | null;
export function getConvertionResultsRequestConfig() {
  return _requestConfigConvertionResults;
}
export function setConvertionResultsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConvertionResults = value;
}
export function patchConvertionResultsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConvertionResults = patch(_requestConfigConvertionResults ?? {});
}

let _requestConfigSoftDelete: Partial<AxiosRequestConfig> | null;
export function getSoftDeleteRequestConfig() {
  return _requestConfigSoftDelete;
}
export function setSoftDeleteRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSoftDelete = value;
}
export function patchSoftDeleteRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSoftDelete = patch(_requestConfigSoftDelete ?? {});
}

let _requestConfigHardDelete: Partial<AxiosRequestConfig> | null;
export function getHardDeleteRequestConfig() {
  return _requestConfigHardDelete;
}
export function setHardDeleteRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigHardDelete = value;
}
export function patchHardDeleteRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigHardDelete = patch(_requestConfigHardDelete ?? {});
}

let _requestConfigCancelDelete: Partial<AxiosRequestConfig> | null;
export function getCancelDeleteRequestConfig() {
  return _requestConfigCancelDelete;
}
export function setCancelDeleteRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCancelDelete = value;
}
export function patchCancelDeleteRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCancelDelete = patch(_requestConfigCancelDelete ?? {});
}

let _requestConfigProfileGET: Partial<AxiosRequestConfig> | null;
export function getProfileGETRequestConfig() {
  return _requestConfigProfileGET;
}
export function setProfileGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigProfileGET = value;
}
export function patchProfileGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigProfileGET = patch(_requestConfigProfileGET ?? {});
}

let _requestConfigProfilePATCH: Partial<AxiosRequestConfig> | null;
export function getProfilePATCHRequestConfig() {
  return _requestConfigProfilePATCH;
}
export function setProfilePATCHRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigProfilePATCH = value;
}
export function patchProfilePATCHRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigProfilePATCH = patch(_requestConfigProfilePATCH ?? {});
}

let _requestConfigGetWeatherForecast: Partial<AxiosRequestConfig> | null;
export function getGetWeatherForecastRequestConfig() {
  return _requestConfigGetWeatherForecast;
}
export function setGetWeatherForecastRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetWeatherForecast = value;
}
export function patchGetWeatherForecastRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetWeatherForecast = patch(_requestConfigGetWeatherForecast ?? {});
}